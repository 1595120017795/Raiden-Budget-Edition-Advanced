{"README.md":" \n\n\n> Open this page at [https://riknoll.github.io/arcade-custom-menu/](https://riknoll.github.io/arcade-custom-menu/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://arcade.makecode.com/](https://arcade.makecode.com/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/riknoll/arcade-custom-menu** and import\n\n## Edit this project ![Build status badge](https://github.com/riknoll/arcade-custom-menu/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://arcade.makecode.com/](https://arcade.makecode.com/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/riknoll/arcade-custom-menu** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/riknoll/arcade-custom-menu/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/arcade\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","api.ts":"enum MenuLocation {\n    //% block=\"full screen\"\n    FullScreen,\n    //% block=\"centered\"\n    Center,\n    //% block=\"top half\"\n    TopHalf,\n    //% block=\"right half\"\n    RightHalf,\n    //% block=\"bottom half\"\n    BottomHalf,\n    //% block=\"left half\"\n    LeftHalf,\n    //% block=\"top right\"\n    TopRight,\n    //% block=\"bottom right\"\n    BottomRight,\n    //% block=\"bottom left\"\n    BottomLeft,\n    //% block=\"top left\"\n    TopLeft\n}\n\nenum MenuStyle {\n    //% block=\"grid\"\n    Grid,\n    //% block=\"list\"\n    List\n}\n\nnamespace blockMenu {\n    //% blockId=\"block_menu_show_menu\"\n    //% block=\"show $style menu at $location with options $options\"\n    //% options.shadow=\"lists_create_with\"\n    //% options.defl=\"text\"\n    export function showMenu(options: string[], style: MenuStyle, location: MenuLocation) {\n        const state = _getState();\n\n        state.menu.setOptions(options);\n        state.menu.setStyle(style);\n        state.menu.setLocation(location);\n        state.menu.setMenuOpen(true);\n    }\n\n    //% blockId=\"block_menu_close_menu\"\n    //% block=\"close menu\"\n    export function closeMenu() {\n        const state = _getState();\n        state.menu.setMenuOpen(false);\n    }\n\n    //% blockId=\"block_menu_set_colors\"\n    //% block=\"set menu foreground $foreground background $background\"\n    //% foreground.shadow=colorindexpicker\n    //% foreground.defl=15\n    //% background.shadow=colorindexpicker\n    //% background.defl=1\n    export function setColors(foreground: number, background: number) {\n        const state = _getState();\n        state.menu.setColors(foreground, background, background, foreground);\n    }\n\n    //% blockId=\"block_menu_selected_menu_option\"\n    //% block=\"selected menu option\"\n    export function selectedMenuOption(): string {\n        const state = _getState();\n        return state.menu.selectedMenuOption();\n    }\n\n    //% blockId=\"block_menu_selected_menu_index\"\n    //% block=\"selected menu index\"\n    export function selectedMenuIndex(): number {\n        const state = _getState();\n        return state.menu.selectedMenuIndex();\n    }\n\n    //% blockId=\"block_menu_is_menu_open\"\n    //% block=\"is menu open\"\n    export function isMenuOpen(): boolean {\n        const state = _getState();\n        return state.menu.isOpen();\n    }\n\n    //% blockId=\"block_menu_on_menu_option_selected\"\n    //% block=\"on menu option selected $option $index\"\n    //% draggableParameters=\"reporter\"\n    export function onMenuOptionSelected(handler: (option: string, index: number) => void) {\n        const state = _getState();\n        state.addHandler(handler);\n    }\n\n    //% blockId=\"block_menu_set_selected_index\"\n    //% block=\"set selected index $index\"\n    export function setSelectedIndex(index: number) {\n        const state = _getState();\n        state.menu.setSelectedIndex(index);\n    }\n\n    //% blockId=\"block_menu_set_selected_option\"\n    //% block=\"set selected option $option\"\n    export function setSelectedOption(option: string) {\n        const state = _getState();\n        state.menu.setSelectedOption(option);\n    }\n\n    //% blockId=\"block_menu_set_controls_enabled\"\n    //% block=\"set controls enabled $enabled\"\n    export function setControlsEnabled(enabled: boolean) {\n        const state = _getState();\n        state.controlsEnabled = enabled;\n    }\n}","main.ts":"\n\n\n// blockMenu.showMenu([\n//     \"whatever\",\n//     \"hello\",\n//     \"goodbye\",\n//     \"hello\",\n//     \"goodbye\",\n//     \"hello\",\n//     \"goodbye\",\n// ], MenuStyle.List, MenuLocation.RightHalf)\n\n\n// blockMenu.onMenuOptionSelected(function(option: string, index: number) {\n//     console.log(option)\n// })","menu.ts":"namespace blockMenu {\n    class LayoutMetrics {\n        constructor(public left: number, public top: number, public width: number, public height: number) {\n        }\n\n        get right() {\n            return this.left + this.width;\n        }\n\n        get bottom() {\n            return this.top + this.height;\n        }\n    }\n\n    export class MenuSprite extends sprites.BaseSprite {\n        style: MenuStyle;\n        protected location: MenuLocation;\n\n        protected options: string[];\n        protected labels: ScrollingLabel[];\n        protected selectedIndex: number;\n\n        protected foreground: number;\n        protected background: number;\n        protected cursorBackground: number;\n        protected cursorForeground: number;\n        protected open: boolean;\n\n        protected padding: number;\n        protected metrics: LayoutMetrics;\n\n        constructor() {\n            super(100);\n            this.selectedIndex = 0;\n            this.style = MenuStyle.List;\n            this.setLocation(MenuLocation.Center);\n            this.open = false;\n            this.setColors(15, 1, 1, 3);\n            this.padding = 2;\n        }\n\n        setOptions(options: string[]) {\n            this.options = options.slice();\n            this.selectedIndex = 0;\n            this.recreateLabels();\n        }\n\n        setColors(foreground: number, background: number, cursorForeground: number, cursorBackground: number) {\n            this.foreground = Math.max(Math.min(foreground | 0, 15), 0);\n            this.background = Math.max(Math.min(background | 0, 15), 0);\n            this.cursorForeground = Math.max(Math.min(cursorForeground | 0, 15), 0);\n            this.cursorBackground = Math.max(Math.min(cursorBackground | 0, 15), 0);\n        }\n        \n        setStyle(style: MenuStyle) {\n            this.style = style;\n        }\n\n        setLocation(location: MenuLocation) {\n            this.location = location;\n            this.metrics = getLayoutMetrics(location);\n            this.recreateLabels();\n        }\n\n        selectedMenuOption(): string {\n            if (!this.options || !this.options[this.selectedIndex]) {\n                return \"\";\n            }\n\n            return this.options[this.selectedIndex];\n        }\n\n        selectedMenuIndex(): number {\n            return this.selectedIndex;\n        }\n\n        setSelectedIndex(index: number) {\n            const numOptions = this.options ? this.options.length : 0;\n            if (!numOptions) return;\n\n            index |= 0;\n            while (index < 0) index += this.options.length;\n\n            index = index % numOptions;\n\n            if (this.labels && this.labels[this.selectedIndex]) {\n                this.labels[this.selectedIndex].setScrolling(false);\n            }\n\n            this.selectedIndex = index;\n\n            if (this.labels && this.labels[this.selectedIndex]) {\n                this.labels[this.selectedIndex].setScrolling(true);\n            }\n        }\n\n        moveSelectionVertical(up: boolean) {\n            if (this.style === MenuStyle.Grid) {\n                if (up) {\n                    if (this.options && this.options.length & 1) {\n                        if (this.selectedIndex === 0) {\n                            this.setSelectedIndex(this.selectedIndex - 1)\n                        }\n                        else if (this.selectedIndex === 1) {\n                            this.setSelectedIndex(this.selectedIndex - 3)\n                        }\n                        else {\n                            this.setSelectedIndex(this.selectedIndex - 2)\n                        }\n                    }\n                    else {\n                        this.setSelectedIndex(this.selectedIndex - 2)\n                    }\n                }\n                else {\n                    if (this.options && this.options.length & 1 && this.selectedIndex >= this.options.length - 2) {\n                        this.setSelectedIndex(this.selectedIndex + 1)\n                    }\n                    else {\n                        this.setSelectedIndex(this.selectedIndex + 2)\n                    }\n                }\n            }\n            else {\n                if (up) {\n                    this.previous()\n                }\n                else {\n                    this.next();\n                }\n            }\n        }\n\n        moveSelectionHorizontal(left: boolean) {\n            if (this.style === MenuStyle.Grid) {\n                if (this.selectedIndex % 2 === 0) {\n                    this.setSelectedIndex(this.selectedIndex + 1);\n                }\n                else {\n                    this.setSelectedIndex(this.selectedIndex - 1);\n                }\n            }\n        }\n\n        next() {\n            this.setSelectedIndex(this.selectedIndex + 1);\n        }\n\n        previous() {\n            this.setSelectedIndex(this.selectedIndex - 1);\n        }\n\n        setSelectedOption(option: string) {\n            const index = this.options ? this.options.indexOf(option) : -1;\n\n            if (index !== -1) {\n                this.setSelectedIndex(index);\n            }\n        }\n\n        isOpen(): boolean {\n            return this.open;\n        }\n\n        setMenuOpen(open: boolean) {\n            this.open = open;\n        }\n\n        destroy() {\n            game.currentScene().allSprites.removeElement(this);\n        }\n\n        __visible(): boolean {\n            return this.open;\n        }\n\n        __drawCore(camera: scene.Camera) {\n            if (this.background) {\n                screen.fillRect(\n                    this.metrics.left,\n                    this.metrics.top,\n                    this.metrics.width,\n                    this.metrics.height,\n                    this.background\n                );\n            }\n\n            if (this.style === MenuStyle.Grid) {\n                this.drawGridMenu();\n            }\n            else {\n                this.drawListMenu();\n            }\n        }\n\n        protected getMaxLabelWidth() {\n            if (this.style === MenuStyle.Grid) {\n                return (this.metrics.width - (this.padding * 3)) >> 1;\n            }\n            return this.metrics.width - (this.padding << 1);\n        }\n\n        protected recreateLabels() {\n            this.labels = [];\n            if (!this.options) return;\n\n            const labelWidth = this.getMaxLabelWidth();\n\n            for (const option of this.options) {\n                this.labels.push(new ScrollingLabel(option, labelWidth));\n            }\n\n            this.setSelectedIndex(this.selectedMenuIndex())\n        }\n\n        protected drawGridMenu() {\n            let current: ScrollingLabel;\n\n            let top = this.metrics.top + this.padding;\n            let left = this.metrics.left + this.padding;\n\n            for (let i = 0; i < this.labels.length; i++) {\n                current = this.labels[i];\n\n                if (i === this.selectedIndex) {\n                    screen.fillRect(left - 1, top - 1, current.width + 2, current.font.charHeight + 2, this.cursorBackground);\n                    current.draw(left, top, this.cursorForeground);\n                }\n                else {\n                    current.draw(left, top, this.foreground);\n                }\n\n                if (i % 2 === 1) {\n                    left = this.metrics.left + this.padding;\n                    top += current.font.charHeight + this.padding;\n                }\n                else {\n                    left += current.width + this.padding;\n                }\n            }\n        }\n\n        protected drawListMenu() {\n            let current: ScrollingLabel;\n\n            let top = this.metrics.top + this.padding;\n            let left = this.metrics.left + this.padding;\n\n            for (let i = 0; i < this.labels.length; i++) {\n                current = this.labels[i];\n                if (i === this.selectedIndex) {\n                    screen.fillRect(left - 1, top - 1, current.width + 2, current.font.charHeight + 2, this.cursorBackground);\n                    current.draw(left, top, this.cursorForeground);\n                }\n                else {\n                    current.draw(left, top, this.foreground);\n                }\n\n                top += current.font.charHeight + this.padding\n            }\n        }\n    }\n\n    class ScrollingLabel {\n        public offset: number;\n\n        public stage: number;\n        public timer: number;\n        public scrolling: boolean;\n        public pauseTime: number;\n        public maxCharacters: number;\n        public maxOffset: number;\n        public width: number;\n        public font: image.Font;\n        public partialCanvas: Image;\n\n        constructor(public text: string, maxWidth: number) {\n            this.scrolling = false;\n\n            this.pauseTime = 1000;\n            this.timer = this.pauseTime;\n            this.stage = 0;\n            this.offset = 0;\n            this.width = maxWidth;\n\n            this.font = image.getFontForText(this.text);\n\n            const fullLength = this.text.length * this.font.charWidth;\n            this.maxCharacters = Math.idiv(maxWidth, this.font.charWidth);\n            this.maxOffset = fullLength - this.maxCharacters * this.font.charWidth;\n            this.partialCanvas = image.create(this.font.charWidth, this.font.charHeight);\n        }\n\n        setScrolling(scrolling: boolean) {\n            if (this.scrolling !== scrolling) {\n                this.stage = 0;\n                this.offset = 0;\n                this.scrolling = scrolling;\n            }\n        }\n\n        draw(left: number, top: number, color: number) {\n            const startIndex = Math.idiv(this.offset, this.font.charWidth);\n            const letterOffset = startIndex * this.font.charWidth - this.offset;\n\n            if (!this.scrolling) {\n                this.offset = 0;\n            }\n            else if (this.stage === 1) {\n                this.offset++;\n                if (this.offset >= this.maxOffset) {\n                    this.stage++;\n                    this.offset = Math.max(this.maxOffset, 0);\n                }\n            }\n            else {\n                if (this.stage === 0) {\n                    this.offset = 0;\n                }\n                else if (this.stage === 2) {\n                    this.offset = Math.max(this.maxOffset, 0);\n                }\n\n                this.timer -= game.currentScene().eventContext.deltaTimeMillis;\n\n                if (this.timer < 0) {\n                    this.stage = (this.stage + 1) % 3;\n                    this.timer = this.pauseTime;\n                }\n            }\n\n            if (letterOffset) {\n                this.partialCanvas.fill(0);\n                this.partialCanvas.print(this.text.charAt(startIndex), letterOffset, 0, color, this.font)\n                screen.drawTransparentImage(this.partialCanvas, left, top);\n            }\n            else {\n                screen.print(this.text.charAt(startIndex), left, top, color, this.font);\n            }\n\n            for (let i = 1; i < this.maxCharacters; i++) {\n                screen.print(\n                    this.text.charAt(startIndex + i),\n                    left + i * this.font.charWidth + letterOffset,\n                    top,\n                    color,\n                    this.font\n                );\n            }\n        }\n    }\n\n    function getLayoutMetrics(layout: MenuLocation) {\n        const padding = 2;\n\n        const maxWidth = screen.width - (padding << 1);\n        const maxHeight = screen.height - (padding << 1);\n\n        switch (layout) {\n            case MenuLocation.FullScreen:\n                return new LayoutMetrics(padding, padding, maxWidth, maxHeight);\n            case MenuLocation.Center:\n                return new LayoutMetrics(0, 0, 0, 0);\n            case MenuLocation.TopHalf:\n                return new LayoutMetrics(padding, padding, maxWidth, maxHeight >> 1);\n            case MenuLocation.RightHalf:\n                return new LayoutMetrics(screen.width >> 1, padding, maxWidth >> 1, maxHeight);\n            case MenuLocation.BottomHalf:\n                return new LayoutMetrics(padding, screen.height >> 1, maxWidth, maxHeight >> 1);\n            case MenuLocation.LeftHalf:\n                return new LayoutMetrics(padding, padding, maxWidth >> 1, maxHeight);\n            case MenuLocation.TopRight:\n                return new LayoutMetrics(screen.width >> 1, padding, maxWidth >> 1, maxHeight >> 1);\n            case MenuLocation.BottomRight:\n                return new LayoutMetrics(screen.width >> 1, screen.height >> 1, maxWidth >> 1, maxHeight >> 1);\n            case MenuLocation.BottomLeft:\n                return new LayoutMetrics(padding, screen.height >> 1, maxWidth >> 1, maxHeight >> 1);\n            case MenuLocation.TopLeft:\n                return new LayoutMetrics(padding, padding, maxWidth >> 1, maxHeight >> 1);\n        }\n    }\n}","menuState.ts":"namespace blockMenu {\n    let state: _BlockMenuState;\n    let sceneStack: _BlockMenuState[];\n\n    export class _BlockMenuState {\n        menu: MenuSprite;\n        handlers: ((option: string, index: number) => void)[];\n        controlsEnabled: boolean;\n\n        constructor() {\n            this.menu = new MenuSprite();\n            this.handlers = [];\n            this.controlsEnabled = true;\n        }\n\n        addHandler(handler: ((option: string, index: number) => void)) {\n            if (handler) {\n                this.handlers.push(handler);\n            }\n        }\n\n        runHandlers(option: string, index: number) {\n            if (this.handlers.length) {\n                control.runInParallel(() => {\n                    for (const handler of this.handlers) {\n                        handler(option, index)\n                    }\n                });\n            }\n        }\n\n        destroy() {\n            this.menu.destroy();\n        }\n    }\n\n    enum button {\n        u = 1,\n        r = 1 << 1,\n        d = 1 << 2,\n        l = 1 << 3,\n        a = 1 << 4,\n        b = 1 << 5\n    }\n\n    export function _init() {\n        if (sceneStack) return;\n        sceneStack = [];\n        state = new _BlockMenuState();\n\n        // can't use controller events because it would override\n        // the user's controller handlers. this works okay but\n        // it's a little glitchy in the grid layout\n        let debounce = 100;\n        control.runInParallel(function() {\n            while (true) {\n                controller.pauseUntilAnyButtonIsPressed();\n                if (!state.controlsEnabled) continue;\n\n                if (state.menu.style === MenuStyle.Grid) {\n                    debounce = 150\n                }\n                else {\n                    debounce = 100;\n                }\n\n                if (controller.A.isPressed()) {\n                    for (const handler of state.handlers) {\n                        handler(state.menu.selectedMenuOption(), state.menu.selectedMenuIndex());\n                    }\n\n                    pause(debounce);\n                }\n                if (controller.up.isPressed()) {\n                    state.menu.moveSelectionVertical(true);\n                    pause(debounce);\n                }\n                if (controller.down.isPressed()) {\n                    state.menu.moveSelectionVertical(false);\n                    pause(debounce);\n                }\n                if (controller.left.isPressed()) {\n                    state.menu.moveSelectionHorizontal(true);\n                    pause(debounce);\n                }\n                if (controller.right.isPressed()) {\n                    state.menu.moveSelectionHorizontal(false);\n                    pause(debounce);\n                }\n            }\n        })\n\n        game.addScenePushHandler(function (oldScene: scene.Scene) {\n            sceneStack.push(state);\n            state = new _BlockMenuState();\n        });\n\n        game.addScenePopHandler(function (oldScene: scene.Scene) {\n            if (sceneStack.length) {\n                state = sceneStack.pop();\n            }\n            else {\n                if (state) {\n                    state.destroy();\n                }\n                state = new _BlockMenuState();\n            }\n        });\n    }\n\n    export function _getState() {\n        _init();\n        return state;\n    }\n}","pxt.json":"{\n    \"name\": \"block-menu\",\n    \"version\": \"0.0.1\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"hw---samd51\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"api.ts\",\n        \"menu.ts\",\n        \"menuState.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v1.0.16\",\n        \"tag\": \"v1.0.16\",\n        \"commits\": \"https://github.com/microsoft/pxt-arcade/commits/3d3129177a6331fa694e0eb095a96de316256656\",\n        \"target\": \"1.0.16\",\n        \"pxt\": \"6.1.42\",\n        \"targetId\": \"arcade\"\n    },\n    \"supportedTargets\": [\n        \"arcade\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}